//! Dirichlet character computation.
//!
//! Provides tools for enumerating and evaluating Dirichlet characters mod N,
//! including the Kronecker symbol for quadratic characters.

use crate::complex::{self, Complex};
use num_integer::Integer;
use std::f64::consts::PI;

/// A Dirichlet character mod N, stored as a table of values.
///
/// For a in [0, N), `values[a]` is χ(a) as a complex number.
/// If gcd(a, N) > 1, then χ(a) = 0.
#[derive(Debug, Clone)]
pub struct DirichletChar {
    /// The modulus N of this character.
    pub modulus: u64,
    /// Table of values: values[a] = χ(a) for a in [0, N).
    pub values: Vec<Complex>,
    /// Whether this is the principal character (trivial).
    pub is_principal: bool,
}

impl DirichletChar {
    /// Evaluate χ(n) for any n (reduces mod N first).
    pub fn eval(&self, n: u64) -> Complex {
        let idx = (n % self.modulus) as usize;
        self.values[idx]
    }

    /// Check if the character is real-valued (all imaginary parts near zero).
    pub fn is_real(&self) -> bool {
        self.values.iter().all(|v| v.1.abs() < 1e-10)
    }
}

/// Compute Euler's totient function φ(n).
pub fn euler_totient(n: u64) -> u64 {
    if n == 0 {
        return 0;
    }
    if n == 1 {
        return 1;
    }

    let mut result = n;
    let mut temp = n;
    let mut p = 2u64;

    while p * p <= temp {
        if temp % p == 0 {
            while temp % p == 0 {
                temp /= p;
            }
            result -= result / p;
        }
        p += 1;
    }
    if temp > 1 {
        result -= result / temp;
    }
    result
}

/// Find the prime factorization of n.
pub fn factorize(n: u64) -> Vec<(u64, u32)> {
    let mut factors = Vec::new();
    let mut temp = n;
    let mut p = 2u64;

    while p * p <= temp {
        if temp % p == 0 {
            let mut exp = 0u32;
            while temp % p == 0 {
                temp /= p;
                exp += 1;
            }
            factors.push((p, exp));
        }
        p += 1;
    }
    if temp > 1 {
        factors.push((temp, 1));
    }
    factors
}

/// Find a primitive root modulo p (p must be prime).
///
/// Returns None if p is not prime or no primitive root exists.
pub fn primitive_root(p: u64) -> Option<u64> {
    if p <= 1 {
        return None;
    }
    if p == 2 {
        return Some(1);
    }

    let phi = p - 1;
    let factors = factorize(phi);

    'outer: for g in 2..p {
        for &(q, _) in &factors {
            if mod_pow(g, phi / q, p) == 1 {
                continue 'outer;
            }
        }
        return Some(g);
    }
    None
}

/// Modular exponentiation: base^exp mod modulus.
pub fn mod_pow(base: u64, mut exp: u64, modulus: u64) -> u64 {
    if modulus == 1 {
        return 0;
    }
    let mut result = 1u128;
    let mut base = base as u128;
    let modulus = modulus as u128;
    base %= modulus;

    while exp > 0 {
        if exp & 1 == 1 {
            result = (result * base) % modulus;
        }
        exp >>= 1;
        base = (base * base) % modulus;
    }
    result as u64
}

/// Generator and order pair for the multiplicative group (Z/NZ)*.
#[derive(Debug, Clone)]
pub struct GroupGenerator {
    /// The generator element.
    pub generator: u64,
    /// The order of this generator.
    pub order: u64,
}

/// Compute generators and their orders for the multiplicative group (Z/NZ)*.
///
/// The group (Z/NZ)* is a product of cyclic groups. For N = p1^e1 * ... * pk^ek,
/// each factor contributes a cyclic component. We return generators for each component.
pub fn multiplicative_group_generators(n: u64) -> Vec<GroupGenerator> {
    if n <= 2 {
        return vec![];
    }

    let factors = factorize(n);
    let mut generators = Vec::new();

    for &(p, e) in &factors {
        let pe = p.pow(e);

        if p == 2 {
            if e == 1 {
                // (Z/2Z)* is trivial
                continue;
            } else if e == 2 {
                // (Z/4Z)* = {1, 3}, generated by 3
                let g = lift_to_n(3, 4, n);
                generators.push(GroupGenerator {
                    generator: g,
                    order: 2,
                });
            } else {
                // (Z/2^e Z)* ≅ Z/2 × Z/2^{e-2}
                // Generated by -1 and 5
                let g1 = lift_to_n(pe - 1, pe, n); // -1 mod 2^e
                generators.push(GroupGenerator {
                    generator: g1,
                    order: 2,
                });

                let g2 = lift_to_n(5, pe, n);
                generators.push(GroupGenerator {
                    generator: g2,
                    order: 1u64 << (e - 2),
                });
            }
        } else {
            // (Z/p^e Z)* is cyclic of order p^{e-1}(p-1)
            // Find primitive root mod p, then lift to p^e
            if let Some(g_p) = primitive_root(p) {
                let g_pe = lift_primitive_root(g_p, p, e);
                let g = lift_to_n(g_pe, pe, n);
                let order = (p - 1) * p.pow(e - 1);
                generators.push(GroupGenerator {
                    generator: g,
                    order,
                });
            }
        }
    }

    generators
}

/// Lift a residue `a mod m` to a residue mod n using CRT.
/// Finds x such that x ≡ a (mod m) and x ≡ 1 (mod n/m), assuming gcd(m, n/m) = 1.
fn lift_to_n(a: u64, m: u64, n: u64) -> u64 {
    if n == m {
        return a % n;
    }
    let other = n / m;
    // We need x ≡ a (mod m), x ≡ 1 (mod other)
    // Use CRT: x = a * other * (other^{-1} mod m) + 1 * m * (m^{-1} mod other)
    let inv_other_mod_m = mod_inverse(other % m, m);
    let inv_m_mod_other = mod_inverse(m % other, other);

    let term1 = ((a as u128) * (other as u128) % (n as u128)
        * (inv_other_mod_m as u128)
        % (n as u128)) as u64;
    let term2 = ((1u128) * (m as u128) % (n as u128) * (inv_m_mod_other as u128)
        % (n as u128)) as u64;

    ((term1 as u128 + term2 as u128) % n as u128) as u64
}

/// Compute the modular inverse of a mod m using the extended Euclidean algorithm.
fn mod_inverse(a: u64, m: u64) -> u64 {
    if m == 1 {
        return 0;
    }
    let a = a % m;
    if a == 0 {
        return 0; // No inverse
    }
    let (mut old_r, mut r) = (a as i128, m as i128);
    let (mut old_s, mut s) = (1i128, 0i128);

    while r != 0 {
        let quotient = old_r / r;
        let temp_r = r;
        r = old_r - quotient * r;
        old_r = temp_r;
        let temp_s = s;
        s = old_s - quotient * s;
        old_s = temp_s;
    }

    ((old_s % m as i128 + m as i128) % m as i128) as u64
}

/// Lift a primitive root from mod p to mod p^e using Hensel's lemma.
fn lift_primitive_root(g: u64, p: u64, e: u32) -> u64 {
    if e == 1 {
        return g;
    }
    // A primitive root mod p is usually also a primitive root mod p^e,
    // unless g^{p-1} ≡ 1 (mod p^2). In that case, use g + p instead.
    let mut g = g;
    let pe = p.pow(e);
    let order = (p - 1) * p.pow(e - 1);

    // Check if g is a primitive root mod p^e
    if mod_pow(g, order / p, pe) == 1 || (p > 2 && mod_pow(g, p - 1, p * p) == 1) {
        g += p; // Adjust to get a primitive root mod p^e
    }

    // Verify: g should have order φ(p^e) = (p-1)*p^{e-1}
    // The order must divide φ(p^e) and not divide any proper divisor
    g % pe
}

/// Enumerate all Dirichlet characters mod N.
///
/// This uses the structure of (Z/NZ)* as a product of cyclic groups.
/// Each character is determined by the images of the generators.
pub fn enumerate_characters(n: u64) -> Vec<DirichletChar> {
    if n <= 1 {
        return vec![DirichletChar {
            modulus: 1,
            values: vec![complex::ONE],
            is_principal: true,
        }];
    }

    let generators = multiplicative_group_generators(n);

    if generators.is_empty() {
        // (Z/NZ)* is trivial (N = 1 or 2)
        let mut values = vec![complex::ZERO; n as usize];
        for a in 0..n {
            if a.gcd(&n) == 1 {
                values[a as usize] = complex::ONE;
            }
        }
        return vec![DirichletChar {
            modulus: n,
            values,
            is_principal: true,
        }];
    }

    // Build the discrete log table: for each a coprime to N,
    // find exponents (e1, e2, ...) such that a = g1^e1 * g2^e2 * ... (mod N)
    let dlog_table = build_discrete_log_table(n, &generators);

    // Enumerate all characters by iterating over all possible images of generators
    let mut characters = Vec::new();
    let orders: Vec<u64> = generators.iter().map(|g| g.order).collect();
    let total_chars: u64 = orders.iter().product();

    for char_index in 0..total_chars {
        // Decode char_index into exponents for each generator
        let mut exponents = Vec::with_capacity(orders.len());
        let mut idx = char_index;
        for &ord in &orders {
            exponents.push(idx % ord);
            idx /= ord;
        }

        // Build the character values
        let mut values = vec![complex::ZERO; n as usize];
        let mut is_principal = true;

        for a in 0..n {
            if a.gcd(&n) != 1 {
                continue;
            }

            if let Some(logs) = dlog_table.get(&a) {
                // χ(a) = product over i of ω_i^{exponents[i] * logs[i]}
                // where ω_i = e^{2πi / orders[i]}
                let mut value = complex::ONE;
                for (i, (&exp, &log)) in exponents.iter().zip(logs.iter()).enumerate() {
                    let angle = 2.0 * PI * (exp as f64) * (log as f64) / (orders[i] as f64);
                    value = complex::cmul(value, complex::cis(angle));
                }
                values[a as usize] = value;

                if is_principal && complex::cnorm_sq(complex::csub(value, complex::ONE)) > 1e-10 {
                    is_principal = false;
                }
            }
        }

        characters.push(DirichletChar {
            modulus: n,
            values,
            is_principal,
        });
    }

    characters
}

/// Discrete logarithm table mapping: a -> (log_{g1}(a), log_{g2}(a), ...)
///
/// For each a coprime to N, find the exponents such that a = g1^e1 * g2^e2 * ... (mod N).
fn build_discrete_log_table(
    n: u64,
    generators: &[GroupGenerator],
) -> std::collections::HashMap<u64, Vec<u64>> {
    use std::collections::HashMap;

    // For each generator, build a table of its powers
    let mut gen_power_tables: Vec<HashMap<u64, u64>> = Vec::new();

    for gen in generators {
        let mut table = HashMap::new();
        let mut power = 1u64;
        for exp in 0..gen.order {
            table.insert(power, exp);
            power = ((power as u128 * gen.generator as u128) % n as u128) as u64;
        }
        gen_power_tables.push(table);
    }

    // For each a coprime to N, find its discrete logs
    // We use the baby-step giant-step approach for efficiency,
    // but for moderate N we can just search.
    let mut dlog_table = HashMap::new();

    // Generate all elements as products of generator powers
    let orders: Vec<u64> = generators.iter().map(|g| g.order).collect();
    let total: u64 = orders.iter().product();

    for idx in 0..total {
        let mut exps = Vec::with_capacity(orders.len());
        let mut i = idx;
        for &ord in &orders {
            exps.push(i % ord);
            i /= ord;
        }

        let mut element = 1u128;
        for (j, &exp) in exps.iter().enumerate() {
            let pow = mod_pow(generators[j].generator, exp, n);
            element = (element * pow as u128) % n as u128;
        }

        dlog_table.insert(element as u64, exps);
    }

    dlog_table
}

/// Compute the Jacobi/Kronecker symbol (a/n).
///
/// This is the generalization of the Legendre symbol to composite moduli.
pub fn kronecker_symbol(a: i64, n: u64) -> i64 {
    if n == 0 {
        if a.unsigned_abs() == 1 {
            return 1;
        }
        return 0;
    }
    if n == 1 {
        return 1;
    }

    // Handle n = 2 specially
    if n == 2 {
        if a % 2 == 0 {
            return 0;
        }
        let a_mod_8 = ((a % 8) + 8) % 8;
        if a_mod_8 == 1 || a_mod_8 == 7 {
            return 1;
        }
        return -1;
    }

    // Factor out powers of 2 from n
    let mut n = n;
    let mut result: i64 = 1;

    // Handle factor of 2
    while n % 2 == 0 {
        n /= 2;
        let a_mod_8 = ((a % 8) + 8) % 8;
        if a % 2 == 0 {
            return 0;
        }
        if a_mod_8 == 3 || a_mod_8 == 5 {
            result = -result;
        }
    }

    if n == 1 {
        return result;
    }

    // Now n is odd, use Jacobi symbol algorithm
    result *= jacobi_symbol(a, n);
    result
}

/// Compute the Jacobi symbol (a/n) for odd n > 0.
fn jacobi_symbol(a: i64, n: u64) -> i64 {
    if n == 1 {
        return 1;
    }

    let mut a = ((a % n as i64) + n as i64) as u64 % n;
    let mut n = n;
    let mut result = 1i64;

    while a != 0 {
        // Factor out powers of 2 from a
        while a % 2 == 0 {
            a /= 2;
            let n_mod_8 = n % 8;
            if n_mod_8 == 3 || n_mod_8 == 5 {
                result = -result;
            }
        }

        // Quadratic reciprocity
        std::mem::swap(&mut a, &mut n);
        if a % 4 == 3 && n % 4 == 3 {
            result = -result;
        }
        a %= n;
    }

    if n == 1 {
        result
    } else {
        0
    }
}

/// Create the Kronecker character χ_D for fundamental discriminant D.
///
/// This is the character n -> (D|n), which has conductor |D|.
pub fn kronecker_character(d: i64, modulus: u64) -> DirichletChar {
    let mut values = vec![complex::ZERO; modulus as usize];
    let mut is_principal = true;

    for a in 0..modulus {
        let ks = kronecker_symbol(d, a);
        values[a as usize] = (ks as f64, 0.0);
        if a.gcd(&modulus) == 1 && ks != 1 {
            is_principal = false;
        }
    }

    DirichletChar {
        modulus,
        values,
        is_principal,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_euler_totient() {
        assert_eq!(euler_totient(1), 1);
        assert_eq!(euler_totient(2), 1);
        assert_eq!(euler_totient(6), 2);
        assert_eq!(euler_totient(7), 6);
        assert_eq!(euler_totient(12), 4);
        assert_eq!(euler_totient(77), 60); // (7-1)*(11-1)
    }

    #[test]
    fn test_factorize() {
        assert_eq!(factorize(12), vec![(2, 2), (3, 1)]);
        assert_eq!(factorize(77), vec![(7, 1), (11, 1)]);
        assert_eq!(factorize(100), vec![(2, 2), (5, 2)]);
    }

    #[test]
    fn test_primitive_root() {
        assert_eq!(primitive_root(7), Some(3));
        assert_eq!(primitive_root(11), Some(2));
        assert_eq!(primitive_root(13), Some(2));
    }

    #[test]
    fn test_mod_pow() {
        assert_eq!(mod_pow(2, 10, 1000), 24); // 1024 mod 1000
        assert_eq!(mod_pow(3, 6, 7), 1); // Fermat's little theorem
        assert_eq!(mod_pow(5, 0, 13), 1);
    }

    #[test]
    fn test_enumerate_characters_count() {
        // Number of characters mod N = φ(N)
        for n in [5, 7, 11, 12, 13, 15, 77] {
            let chars = enumerate_characters(n);
            assert_eq!(
                chars.len() as u64,
                euler_totient(n),
                "Wrong number of characters mod {}",
                n
            );
        }
    }

    #[test]
    fn test_principal_character() {
        let chars = enumerate_characters(7);
        let principal: Vec<_> = chars.iter().filter(|c| c.is_principal).collect();
        assert_eq!(principal.len(), 1, "Should have exactly one principal character");

        let chi = &principal[0];
        // Principal character is 1 on units, 0 on non-units
        for a in 1..7u64 {
            let v = chi.eval(a);
            assert!(
                (v.0 - 1.0).abs() < 1e-10 && v.1.abs() < 1e-10,
                "Principal char should be 1 on units"
            );
        }
        let v = chi.eval(0);
        assert!(v.0.abs() < 1e-10 && v.1.abs() < 1e-10);
    }

    #[test]
    fn test_character_multiplicativity() {
        let chars = enumerate_characters(7);
        for chi in &chars {
            // χ(ab) = χ(a)χ(b) for all a, b coprime to N
            for a in 1..7u64 {
                for b in 1..7u64 {
                    let ab = (a * b) % 7;
                    let chi_ab = chi.eval(ab);
                    let chi_a_chi_b = complex::cmul(chi.eval(a), chi.eval(b));
                    assert!(
                        complex::cnorm_sq(complex::csub(chi_ab, chi_a_chi_b)) < 1e-8,
                        "Character should be multiplicative: χ({})χ({}) ≠ χ({})",
                        a,
                        b,
                        ab
                    );
                }
            }
        }
    }

    #[test]
    fn test_jacobi_symbol() {
        // Known values: (2/7) = 1, (3/7) = -1
        assert_eq!(jacobi_symbol(2, 7), 1);
        assert_eq!(jacobi_symbol(3, 7), -1);
        assert_eq!(jacobi_symbol(1, 5), 1);
        assert_eq!(jacobi_symbol(0, 5), 0);
    }

    #[test]
    fn test_kronecker_symbol() {
        // (-4 | n) for small n
        // (-4 | 1) = 1, (-4 | 3) = 1, (-4 | 5) = -1 (since -4 ≡ 1 mod 4... actually let's compute)
        // (-4 | n) = (-1 | n) * (4 | n) = (-1 | n) * (2 | n)^2
        // For odd n: (-1 | n) = (-1)^{(n-1)/2}, (2 | n) = (-1)^{(n^2-1)/8}
        assert_eq!(kronecker_symbol(-4, 1), 1);
        assert_eq!(kronecker_symbol(-4, 3), -1); // (-1|3) = -1, (4|3) = 1 -> -1
        assert_eq!(kronecker_symbol(-4, 5), 1); // (-1|5) = 1, (4|5) = 1 -> 1
    }
}
