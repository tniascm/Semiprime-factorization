"""
E7 — Altuğ Beyond Endoscopy Cancellation (runnable sage script)
Measure post-Poisson cancellation in the trace formula geometric side at level N=pq.
"""


# This file was *autogenerated* from the file E7_altug_beyond_endoscopy/run_E7.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_0p0 = RealNumber('0.0'); _sage_const_0p01 = RealNumber('0.01'); _sage_const_1en10 = RealNumber('1e-10'); _sage_const_2 = Integer(2); _sage_const_1p0 = RealNumber('1.0'); _sage_const_50 = Integer(50); _sage_const_15 = Integer(15); _sage_const_300 = Integer(300); _sage_const_6 = Integer(6); _sage_const_5000 = Integer(5000); _sage_const_14 = Integer(14); _sage_const_10 = Integer(10); _sage_const_20 = Integer(20); _sage_const_p7 = RealNumber('.7'); _sage_const_p5 = RealNumber('.5'); _sage_const_1p5 = RealNumber('1.5'); _sage_const_8 = Integer(8); _sage_const_p3 = RealNumber('.3'); _sage_const_150 = Integer(150); _sage_const_70 = Integer(70); _sage_const_0p5 = RealNumber('0.5'); _sage_const_0p9 = RealNumber('0.9'); _sage_const_1p05 = RealNumber('1.05'); _sage_const_0p3 = RealNumber('0.3'); _sage_const_0p6 = RealNumber('0.6')
import time
import sys
import json
import os

import numpy as np

# ─── local orbital integrals ────────────────────────────────────────────────

def local_orbital_integral(t, p):
    """
    Local orbital integral O_p(t) for squarefree level at prime p.
    O_p(t) = 1 + kronecker(t^2 - 4, p)  when p ∤ (t^2-4),
           = 1                            when p | (t^2-4).
    """
    disc = t*t - _sage_const_4 
    if disc % p == _sage_const_0 :
        return _sage_const_1 
    return _sage_const_1  + kronecker_symbol(disc, p)

def orbital_product(t, primes):
    """Product of local orbital integrals over all primes dividing N."""
    r = _sage_const_1 
    for p in primes:
        r *= local_orbital_integral(t, p)
        if r == _sage_const_0 :
            return _sage_const_0 
    return r

# ─── Fourier transform of local orbital data (vectorised over xi) ───────────

def poisson_fourier_all(N, primes):
    """
    Compute hat{O}(xi, N) for all xi in 0..N-1 simultaneously.

    hat{O}(xi) = (1/N) sum_{t=0}^{N-1} O(t,N) e^{2 pi i t xi / N}

    We build the orbital-product vector once, then DFT it.
    Returns a complex numpy array of length N.
    """
    orb = np.array([orbital_product(t, primes) for t in range(N)], dtype=np.float64)
    # DFT: fft computes sum_t orb[t] * exp(-2pi i t xi / N), we want +2pi i,
    # so use ifft * N or just fft of reversed indices.  Easiest: fft then
    # hat{O}(xi) = conj(fft(orb))[xi] / N  =  ifft(orb)[xi] (unnormalised by N).
    # Actually numpy ifft already divides by N, so: hat{O} = ifft(orb) * N / N = ifft(orb)
    # No — let's be careful.
    # We want: hat{O}(xi) = (1/N) sum_t orb[t] exp(+2pi i t xi / N)
    # numpy fft: X[xi] = sum_t x[t] exp(-2pi i t xi / N)
    # So hat{O}(xi) = conj(X[xi]) / N  where X = fft(orb)
    X = np.fft.fft(orb)
    return np.conj(X) / N

# ─── cancellation analysis ──────────────────────────────────────────────────

def cancellation_analysis(N):
    fac = factor(N)
    primes = [int(p) for p, _ in fac]

    # Naive: count non-zero orbital integrals mod N
    naive_nonzero = _sage_const_0 
    naive_weight  = _sage_const_0 
    for t in range(N):
        v = orbital_product(t, primes)
        if v > _sage_const_0 :
            naive_nonzero += _sage_const_1 
            naive_weight  += v

    # Poisson-transformed coefficients (via FFT — O(N log N) not O(N^2))
    coeffs = poisson_fourier_all(N, primes)
    mags   = np.abs(coeffs)

    zero_mode   = mags[_sage_const_0 ]
    nz_mags     = mags[_sage_const_1 :]          # non-zero frequencies
    nz_max      = float(nz_mags.max()) if len(nz_mags) else _sage_const_0p0 
    threshold   = nz_max * _sage_const_0p01  if nz_max > _sage_const_0  else _sage_const_1en10 

    eff_rank    = int(np.sum(nz_mags > threshold))
    total_E     = float(np.sum(mags**_sage_const_2 ))
    cuspidal_E  = float(np.sum(nz_mags**_sage_const_2 ))
    energy_ratio = cuspidal_E / total_E if total_E > _sage_const_0  else _sage_const_0 

    # Which non-zero modes are divisor-related?
    div_modes = _sage_const_0 
    for xi in range(_sage_const_1 , N):
        if gcd(xi, N) > _sage_const_1  and mags[xi] > threshold:
            div_modes += _sage_const_1 

    return {
        'N': int(N),
        'p': int(primes[_sage_const_0 ]) if len(primes) >= _sage_const_1  else None,
        'q': int(primes[_sage_const_1 ]) if len(primes) >= _sage_const_2  else None,
        'naive_nonzero': naive_nonzero,
        'naive_weight':  int(naive_weight),
        'zero_mode_mag': float(zero_mode),
        'eff_rank':      eff_rank,
        'compress':      float(eff_rank) / float(N - _sage_const_1 ) if N > _sage_const_1  else _sage_const_1p0 ,
        'cusp_energy':   energy_ratio,
        'nz_max':        nz_max,
        'nz_mean':       float(nz_mags.mean()) if len(nz_mags) else _sage_const_0 ,
        'nz_l2':         float(np.sqrt(cuspidal_E)),
        'div_modes':     div_modes,
        'sig_nz':        int(np.sum(nz_mags > _sage_const_1en10 )),
    }

# ─── generate semiprimes ────────────────────────────────────────────────────

def gen_semiprimes(max_N, count=_sage_const_50 ):
    targets = np.logspace(np.log10(_sage_const_15 ), np.log10(max_N), count)
    out, seen = [], set()
    for tgt in targets:
        N0 = int(tgt)
        for off in range(_sage_const_300 ):
            c = N0 + off
            if c < _sage_const_6  or c in seen:
                continue
            f = factor(c)
            if len(f) == _sage_const_2  and all(e == _sage_const_1  for _, e in f):
                out.append((c, int(f[_sage_const_0 ][_sage_const_0 ]), int(f[_sage_const_1 ][_sage_const_0 ])))
                seen.add(c)
                break
    return out

# ─── main ───────────────────────────────────────────────────────────────────

print("E7 — Altuğ Beyond Endoscopy Cancellation\n", flush=True)

# Sanity check
print("Sanity check N=15 …", flush=True)
ca15 = cancellation_analysis(_sage_const_15 )
print(f"  naive={ca15['naive_nonzero']}  eff_rank={ca15['eff_rank']}  "
      f"compress={ca15['compress']:.4f}  cusp_E={ca15['cusp_energy']:.4f}", flush=True)
print("  OK\n", flush=True)

semiprimes = gen_semiprimes(_sage_const_5000 , count=_sage_const_50 )
print(f"Semiprimes: {len(semiprimes)}  [{semiprimes[_sage_const_0 ][_sage_const_0 ]}..{semiprimes[-_sage_const_1 ][_sage_const_0 ]}]\n", flush=True)

hdr = f"{'N':>6} {'p':>5} {'q':>5} {'naive':>6} {'eff_rk':>7} {'compress':>9} {'cusp_E':>8} {'div_m':>5} {'time':>8}"
print(hdr, flush=True)
print("-" * len(hdr), flush=True)

results = []
for N, p, q in semiprimes:
    try:
        t0 = time.perf_counter()
        ca = cancellation_analysis(N)
        dt = time.perf_counter() - t0
        ca['time'] = dt
        results.append(ca)
        print(f"{N:>6} {p:>5} {q:>5} {ca['naive_nonzero']:>6} {ca['eff_rank']:>7} "
              f"{ca['compress']:>9.4f} {ca['cusp_energy']:>8.4f} {ca['div_modes']:>5} {dt:>8.3f}s",
              flush=True)
    except Exception as e:
        print(f"  N={N}: ERROR — {e}", flush=True)

print(f"\nCompleted {len(results)} / {len(semiprimes)}\n", flush=True)

# ─── save ────────────────────────────────────────────────────────────────────
data_dir = os.path.join(os.path.dirname(__file__), '..', 'data')
os.makedirs(data_dir, exist_ok=True)
out_path = os.path.join(data_dir, 'E7_cancellation_results.json')
# strip Sage Integer/Rational types for JSON
def _py(v):
    if isinstance(v, (int, float, str, bool, type(None))):
        return v
    try:
        return int(v)
    except (TypeError, ValueError):
        return float(v)
serial = [{k: _py(v) for k, v in r.items()} for r in results]
with open(out_path, 'w') as f:
    json.dump(serial, f, indent=_sage_const_2 )
print(f"Saved {len(serial)} rows → {out_path}\n", flush=True)

# ─── fit & verdict ──────────────────────────────────────────────────────────
from scipy import stats

Ns       = np.array([r['N'] for r in results])
eff_rk   = np.array([r['eff_rank'] for r in results], dtype=float)
compress = np.array([r['compress'] for r in results])
cusp_E   = np.array([r['cusp_energy'] for r in results])

mask = eff_rk > _sage_const_0 
if mask.sum() > _sage_const_2 :
    sl, intc, rv, _, se = stats.linregress(np.log10(Ns[mask]), np.log10(eff_rk[mask]))
    print(f"Effective rank scaling: eff_rank ~ N^{sl:.3f} ± {se:.3f}  R²={rv**_sage_const_2 :.4f}", flush=True)
else:
    sl = float('nan')
    print("Not enough data for fit", flush=True)

print(f"Compression ratio: mean={np.mean(compress):.4f}  median={np.median(compress):.4f}", flush=True)
print(f"Cuspidal energy ratio: mean={np.mean(cusp_E):.4f}", flush=True)
print(flush=True)

# ─── plots ──────────────────────────────────────────────────────────────────
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

fig, axes = plt.subplots(_sage_const_2 , _sage_const_2 , figsize=(_sage_const_14 , _sage_const_10 ))
naive_t = np.array([r['naive_nonzero'] for r in results])

ax = axes[_sage_const_0 ,_sage_const_0 ]
ax.scatter(Ns, eff_rk, s=_sage_const_20 , alpha=_sage_const_p7 , color='blue')
ax.plot(Ns, Ns, 'r--', lw=_sage_const_1 , alpha=_sage_const_p5 , label='O(N)')
if mask.sum() > _sage_const_2 :
    Nf = np.logspace(np.log10(Ns.min()), np.log10(Ns.max()), _sage_const_50 )
    ax.plot(Nf, _sage_const_10 **intc * Nf**sl, 'b--', lw=_sage_const_1p5 , label=f'fit N^{sl:.2f}')
ax.set_xscale('log'); ax.set_yscale('log')
ax.set_xlabel('N'); ax.set_ylabel('Effective rank')
ax.set_title('Post-Cancellation Effective Rank'); ax.legend(fontsize=_sage_const_8 ); ax.grid(True, alpha=_sage_const_p3 )

ax = axes[_sage_const_0 ,_sage_const_1 ]
ax.scatter(Ns, compress, s=_sage_const_20 , alpha=_sage_const_p7 , color='green')
ax.set_xscale('log'); ax.set_xlabel('N'); ax.set_ylabel('eff_rank / (N-1)')
ax.set_title('Compression Ratio vs N'); ax.grid(True, alpha=_sage_const_p3 )

ax = axes[_sage_const_1 ,_sage_const_0 ]
ax.scatter(Ns, cusp_E, s=_sage_const_20 , alpha=_sage_const_p7 , color='red')
ax.set_xscale('log'); ax.set_xlabel('N'); ax.set_ylabel('Cuspidal / Total energy')
ax.set_title('Energy in Non-zero Modes'); ax.grid(True, alpha=_sage_const_p3 )

ax = axes[_sage_const_1 ,_sage_const_1 ]
ax.scatter(naive_t, eff_rk, s=_sage_const_20 , alpha=_sage_const_p7 , color='purple')
mx = max(naive_t.max(), eff_rk.max())
ax.plot([_sage_const_0 , mx], [_sage_const_0 , mx], 'r--', lw=_sage_const_1 , label='No compression')
ax.set_xlabel('Naive non-zero terms'); ax.set_ylabel('Effective rank')
ax.set_title('Naive vs Post-Cancellation'); ax.legend(fontsize=_sage_const_8 ); ax.grid(True, alpha=_sage_const_p3 )

plt.tight_layout()
plt.savefig(os.path.join(data_dir, 'E7_cancellation_plots.png'), dpi=_sage_const_150 )
print(f"Saved plots → data/E7_cancellation_plots.png\n", flush=True)

# ─── verdict ─────────────────────────────────────────────────────────────────
print("=" * _sage_const_70 , flush=True)
print("E7 ALTUG BEYOND ENDOSCOPY — VERDICT", flush=True)
print("=" * _sage_const_70 , flush=True)

if not np.isnan(sl):
    if   sl < _sage_const_0p5 :  v = "VERY PROMISING — substantial cancellation, sublinear residual."
    elif sl < _sage_const_0p9 :  v = "INTERESTING — partial cancellation, growth reduced but near-linear."
    elif sl < _sage_const_1p05 : v = "MARGINAL — near-linear growth. Cancellation doesn't help much."
    else:           v = "NO SIGNIFICANT CANCELLATION — eff_rank grows >= N."
    print(f"  eff_rank ~ N^{sl:.2f}  →  {v}", flush=True)

avg_c = np.mean(compress)
if avg_c < _sage_const_0p3 :
    print("  Compression < 30% — significant structural reduction.", flush=True)
elif avg_c < _sage_const_0p6 :
    print("  Compression 30-60% — moderate reduction.", flush=True)
else:
    print("  Compression > 60% — weak reduction.", flush=True)

print(f"\n  Cuspidal energy fraction: {np.mean(cusp_E):.3f}", flush=True)
print("  (Low = most energy in zero-mode/identity = strong cancellation)", flush=True)
print("  (High = energy spread across modes = weak cancellation)", flush=True)
print(flush=True)

